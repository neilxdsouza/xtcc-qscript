void PrintNamedRange (AbstractNamedRange * nr, vector <string> & group_str, vector <string> & group_list, stringstream & final_answer)
{
	//while (nr) 
	bool added_to_stack = false;
	if (nr) {
		if (NamedRangeGroup * ng = dynamic_cast<NamedRangeGroup*> (nr)) {
			string s (ng->groupName_);
			group_list.push_back ( s);

			cout << "Adding group: " << s 
				<< " onto the stack" << endl;
			if (group_str.size() > 0) {
				group_str[group_str.size() - 1]
					+=  group_list[group_list.size()-2]
						+ ".AddGroup("
						+ s
						+ ");\n";
			}
			//s += " : ";
			group_str.push_back("NamedRangeGroup " + s + "(\"" + s + "\")" +";\n");
			//if (ng->groupPtr_)
			PrintNamedRange (ng->groupPtr_, group_str, group_list, final_answer);
			added_to_stack = true;
		} else if (NamedRangeList * nl = dynamic_cast<NamedRangeList*> (nr)) {
			//group_str[group_str.size() -1 ] += string("|");
			for (int i = 0; i < nl->stubs.size(); ++i) {
				//group_str[group_str.size() - 1] += string("|") + nl->stubs[i].stub_text;
				stringstream s1;
				s1 << group_list[group_list.size()-1]
					<< string(".AddStub( \"") << nl->stubs[i].stub_text
					<< string("\", ")
					<< nl->stubs[i].code
					<< string(", ") << nl->stubs[i].index_in_group 
					<< string(");\n");
				group_str[group_str.size() - 1] 
					+= s1.str();
			}
		}
		//nr = nr->next_nr;
	}
	//if (group_str.size() > 0) 
	if (added_to_stack) {
		final_answer << group_str.back() << endl;
		group_str.pop_back();
		group_list.pop_back();
	}
	cout << "before next recursive call nr: " << nr << endl;
	if (nr->next_nr) {
			PrintNamedRange (nr->next_nr, group_str, group_list, final_answer);
	}
}

