
%{
#include <iostream>
#include <vector>
#include <map>
#include <sstream>
	using namespace std;
#include "question_disk_data.h"
#include "qscript_data.hpp"
#include "const_defs.h"
#include "new_named_range.h"
#include "stub_pair.h" 



	//static vector<int> data;
	//static vector<int> array_index_list;
	//vector <question_disk_data*> qdd_list;
	//map <string, question_disk_data*> qdd_map;
	//QuestionDiskDataMap question_disk_data_map;
	typedef void * yyscan_t;
	int read_disk_datalex(YYSTYPE * yylval_param, yyscan_t yyscanner);
	//int no_errors;
	void read_disk_dataerror(yyscan_t scanner,
		map <string, question_disk_data*>* qdd_map_ptr,
		vector<int>* data,
		vector<int>* array_index_list,
		const char * s);
	// All these 3 global variables have to be parameters 
	// otherwise we are not a re-entrant parser
	vector <int> no_vec;
	vector <int> stub_number;
        vector <stub_pair> stub_list;

%}

%define api.pure
%parse-param	{ yyscan_t yyscanner }
%parse-param 	{ map <string, question_disk_data*>* qdd_map_ptr }
%parse-param 	{ vector<int>* data_ptr }
%parse-param 	{ vector<int>* array_index_list_ptr }
%lex-param	{ yyscan_t yyscanner }

%union {
	int ival;
	double dval;
	char name[/* kept getting an error not defined MY_STR_MAX */ 4095];
	struct AbstractNamedRange * nr_ptr;
}

%token <name> NAME
%token COLON DOLLAR BOUNDS
%token <ival> INUMBER
%token  NEWL

%type <nr_ptr> randomized_data_order
%type <nr_ptr> randomized_data_list
%type <nr_ptr> randomized_data
%type <nr_ptr> simple_number_list



%%

program: question_list{
	//cout << "got question_list: parsed to program: " << endl;
	//return no_errors;
	}
	;

question_list: question
	| question_list question
	;

question: NAME COLON numberlist NEWL {
		//cout << "data<int>[]: ";
		// for(int i=0; i<data.size(); ++i){
		// 	cout << data[i] << " ";
		// }
		//cout << "data.capacity(): " << data.capacity() << endl;
		// cout <<endl;
		//cout << "got question" << endl;
		map <string, question_disk_data*> & qdd_map = * qdd_map_ptr;
		vector<int>& data = * data_ptr;
		string qno($1);
		question_disk_data * qdd = new question_disk_data(qno, data);
		//qdd_list.push_back(qdd);
		qdd_map[qno] = qdd;
		//question_disk_data_map.question_list.push_back(qdd);
		data.clear();
	}
	| NAME COLON NEWL {
		//cout << "got empty question" << endl;
		string qno($1);
		map <string, question_disk_data*> & qdd_map = * qdd_map_ptr;
		question_disk_data * qdd = new question_disk_data(qno);
		qdd_map[qno] = qdd;
		//qdd_list.push_back(qdd);
		//data.clear();
	}
	| NAME array_index_list COLON numberlist NEWL {
		string qno($1);
		vector<int>& data = * data_ptr;
		vector<int>& array_index_list = * array_index_list_ptr;
		question_disk_data * qdd2 = new question_disk_data (qno, array_index_list, data);
		stringstream full_question_name;
		full_question_name << qno;
		for (int i=0; i<array_index_list.size(); ++i) {
			full_question_name << "$" << array_index_list[i];
		}
		map <string, question_disk_data*> & qdd_map = * qdd_map_ptr;
		qdd_map[full_question_name.str()] = qdd2;
		array_index_list.clear();
		cout << " Got array question: " << full_question_name.str()
			<< " data is: " ;
		for (int i=0; i<data.size(); ++i) {
			cout << " " <<  data[i];
		}
		cout << endl;
		data.clear();
		
	}
	| NAME array_index_list COLON NEWL {
		string qno($1);
		vector<int>& array_index_list = * array_index_list_ptr;
		vector<int>& data = * data_ptr;
		question_disk_data * qdd2 = new question_disk_data (qno, array_index_list, data);
		stringstream full_question_name;
		full_question_name << qno;
		for (int i=0; i<array_index_list.size(); ++i) {
			full_question_name << "$" << array_index_list[i];
		}
		map <string, question_disk_data*> & qdd_map = * qdd_map_ptr;
		qdd_map[full_question_name.str()] = qdd2;
		array_index_list.clear();
		data.clear();
		//cout << " Got array question: " << qno << endl;
	}
	| NAME BOUNDS numberlist NEWL{
		string qno($1);
		vector<int>& data = * data_ptr;
		question_disk_data * qdd = new question_disk_data(qno, data, data);
		//qdd_list.push_back(qdd);
		map <string, question_disk_data*> & qdd_map = * qdd_map_ptr;
		qdd_map[qno] = qdd;
		// data will be empty because we reset it - the index has to go into the map
		// otherwise we will dump core at some point
		data.clear();
		//cout << " Got bounds for: " << qno << endl;
	}
	| randomized_data_order NEWL {
	}
	;


randomized_data_order: '{' NAME COLON { cout << "reached here" << endl; ++stub_number[stub_number.size()-1]; stub_number.push_back(0);   } randomized_data_list '}' {
#if 1
		AbstractNamedRange * nr_ptr = $5;
		//cout << "climbing up the chain" << endl;
		while (nr_ptr->prev_nr) {
			//cout << "." ;
			nr_ptr = nr_ptr->prev_nr;
		}
		//cout << endl;
		string grp_name = $2;
		/* the 0 passed here is the line no. It's important when reporting
		* syntax errors to the user, but it seems
		* not so important when reading the randomized order from
		* the data file
		*/
		NamedRangeGroup * nrg = new NamedRangeGroup (0, grp_name, stub_number[stub_number.size()-2]);
		nrg->groupPtr_ = nr_ptr;
		$$ = nrg;
		cout << "NamedRangeGroup: " << grp_name << endl;
		stub_number.pop_back();
#endif /* 0 */
	}
	;

randomized_data_list: randomized_data {
#if 1
			    $$ = $1;
#endif /* 0 */
		}
		| randomized_data_list randomized_data {
#if 1
			$1->next_nr = $2;
			$2->prev_nr = $1;
			AbstractNamedRange * nr = $2;
			NamedRangeGroup * nrg = dynamic_cast<NamedRangeGroup*> (nr);
			if (nrg) {
				cout << "chaining: " << nrg->groupName_ << endl;
			}
			$$ = $2;
#endif /* 0 */
		}
		;


randomized_data:    simple_number_list ';' {
		/* the 0 passed here is the line no. It's important when reporting
		* syntax errors to the user, but it seems
		* not so important when reading the randomized order from
		* the data file
		*/
#if 1
			cout << "got randomized_data" << endl;
			NamedRangeList * nrl = new NamedRangeList(0);
			nrl->stubs = stub_list;
			stub_list.clear();
			$$ = nrl;
#endif /* 0 */
		    }
		    | randomized_data_order   {
#if 1
			$$ = $1;
			cout << " got nested randomized_data_order: " << endl;
#endif /* 0 */
		    }
		    ;

simple_number_list: INUMBER {
			//no_vec.push_back ($1);
			string s1 = "dummy";
			int32_t code=$1;
			++stub_number[stub_number.size()-1];
			struct stub_pair pair1 (s1, code, stub_number.back());
			stub_list.push_back (pair1);
		  }
		  | simple_number_list INUMBER {
			//no_vec.push_back ($2);
			string s1 = "dummy";
			int32_t code=$2;
			++stub_number[stub_number.size()-1];
			struct stub_pair pair1 (s1, code, stub_number.back());
			stub_list.push_back (pair1);
		  }
		  ;

numberlist: INUMBER {
		vector<int>& data = * data_ptr;
		data.push_back($1);
		//cout << "INUMBER: " << $1 << endl;
	}
	|	numberlist INUMBER {
		vector<int>& data = * data_ptr;
		//cout << "INUMBER: " << $2 << endl;
		data.push_back($2);
	}
	;

array_index_list: DOLLAR INUMBER {
		vector<int>& array_index_list = * array_index_list_ptr;
		array_index_list.push_back($2);
	}
	| array_index_list DOLLAR INUMBER {
		vector<int>& array_index_list = * array_index_list_ptr;
		array_index_list.push_back($3);
	}
	;

%%

/*
int main(){
	data.reserve(50);
	qdd_list.reserve(100);
	if(!read_disk_dataparse()&& !no_errors){
		for(int i=0; i< qdd_list.size(); ++i){
			cout << qdd_list[i]->qno << endl;
			cout  << ":" << qdd_list[i]->data.size() << endl;
			for(int j=0; j<qdd_list[i]->data.size(); ++j){
				cout << qdd_list[i]->data[j] << " ";
			}
			cout << endl;
		}
	}  else {
		cout << "errors in parse: " << no_errors;
		return 1;
	}
}

void read_disk_data_init(){
	data.reserve(50);
	//qdd_list.reserve(100);
}
*/
