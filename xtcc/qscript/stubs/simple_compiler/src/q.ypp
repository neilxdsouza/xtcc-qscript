/*
 *  xtcc/xtcc/qscript/stubs/simple_compiler/q.ypp
 *
 *  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Neil Xavier D'Souza
 */

%{

//#include "common.h"

#include <inttypes.h>
#include <sys/types.h>
#include <limits.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstdlib>

//#include "tree.h"
#include "debug_mem.h"
#include "symtab.h"
#include "scope.h"
#include "expr.h"
#include "stmt.h"
#include "named_attributes.h"
#include "named_range.h"
#include "question.h"
#include "QuestionAttributes.h"

#include "qscript_parser.h"

	//using qscript_parser::yyerror;
	//using qscript_parser::yylex;
	//using qscript_parser::yywrap;
	extern int32_t yylex();
	extern void yyerror(const char * s);
	using std::cout;
	using std::cerr;
	using std::endl;
	int32_t flag_cmpd_stmt_is_a_func_body=-1;
	vector </*Statement::*/FunctionInformation*> func_info_table;
	QuestionAttributes question_attributes;
	vector<TextExpression*> text_expr_vec;
	vector<string> vec_named_attribute_list;


%}


%union {
	type_qualifier type_qual;
	int32_t ival;
	double dval;
	char name[MY_STR_MAX];
	char text_buf[MY_STR_MAX];
	DataType dt;
	struct AbstractStatement * stmt;
	struct AbstractExpression * expr;
	//class AbstractQuestion* ques;
	struct CompoundStatement * c_stmt;
	struct FunctionParameter * v_list;


}

%token <ival> INUMBER
%token <dval> FNUMBER
%token <name> NAME
%token TOSTRING
%token <text_buf> TEXT
%token SINGLE_CODED
%token MP
%token <dt> VOID_T
%token <dt> INT8_T
%token <dt> INT16_T
%token <dt> INT32_T
%token <dt> FLOAT_T
%token <dt> DOUBLE_T
%token <dt> STRING_T
%type <dt> datatype
%token IN
%token FOR
%token GOTO
%token HIDDEN
%token ALLOW_BLANK
%token MUTEX
%token CLEAR
%token COLUMN
%token ISANSWERED
%token NEWCARD


%token '['
%token ']'
%token '('
%token ')'
%token '='
%token CONST

%left ','
%right '='
%left LOGOR
%left LOGAND
%left ISEQ NOEQ
%left LEQ GEQ '<' '>'
%left '-' '+'
%left '*' '/' '%'
%nonassoc NOT
%nonassoc UMINUS
%nonassoc IN COUNT
%nonassoc FUNC_CALL


%type <stmt> prog
%type <type_qual> type_qual
%type <stmt> question
%type <stmt> stmt
%type <stmt> expr_stmt
%type <stmt> stmt_list
%type <stmt> decl_stmt
%type <stmt> func_defn
%type <stmt> goto_stmt
%type <stmt> clear_stmt
%type <stmt> column_stmt
%type <stmt> newcard_stmt
 /*%type <stmt> attributes	*/
%type <stmt> stubs
%type <stmt> named_attributes
%type <c_stmt> cmpd_stmt
%type <c_stmt> open_curly
%type <stmt> if_stmt
%type <stmt> for_loop_stmt
%type <stmt> stub_manip_stmts
%type <v_list> var_decl
%type <v_list> decl_comma_list

%token IF ELSE

%token STUBS_LIST
%token NAMED_ATTRIBUTES
%token SETDEL
%token SETADD
%token UNSET
%token SETALL


%type <expr> expression
%type <expr> expr_list


%%


prog: NAME cmpd_stmt {
		qscript_parser::project_name = $1;
		qscript_parser::tree_root=$2;
		while(qscript_parser::tree_root->prev_) {
			cerr << "This should never appear: climbing up the tree" << endl;
			qscript_parser::tree_root=qscript_parser::tree_root->prev_;
		}
	}
	| func_defn {
		$$=$1;
	}
	;

func_defn:
	datatype NAME '(' decl_comma_list ')' {
		string func_name_index($2);
		flag_cmpd_stmt_is_a_func_body=lookup_func(func_name_index);
		if(flag_cmpd_stmt_is_a_func_body==-1){
			ostringstream err_mesg;
			err_mesg << "Function name : " << func_name_index <<  "not found in list of declared functions: "
				<< "You will see another error on this same function name: " << func_name_index;
			print_err(compiler_sem_err
					, err_mesg.str().c_str(),
					qscript_parser::line_no, __LINE__, __FILE__  );
		}
	} cmpd_stmt {
		struct /* Statement:: */ CompoundStatement* c_stmt= $7;
		if(c_stmt==0){
			cerr << "INTERNAL COMPILER ERROR: c_stmt==0" << endl;
		} else {
			//cout << "funcBody_: is valid " << endl;
		}
		struct Scope *scope_=c_stmt->scope_;
		struct /*Statement::*/ FunctionParameter * v_list=qscript_parser::trav_chain($4);
		struct /*Statement::*/ AbstractStatement* funcBody_=$7;
		string search_for=$2;
		DataType returnType_=$1;
		$$=new /*Statement::*/ FunctionStatement(FUNC_DEFN, qscript_parser::line_no, scope_, v_list, funcBody_, search_for, returnType_);
		// Note that the declaration already has a parameter list
		// the constructor uses the parameter list - name and type to verify everything
		// but doesnt need the parameter list any more - so we should delete it
		// - took me a while to figure out this memory leak
		delete v_list;
		free($2);
	}
	;

decl_comma_list: var_decl	{
		 $$=$1;
		 //cout << "got decl_comma_list : " << endl;
	}
	| decl_comma_list ',' var_decl {
		$$=qscript_parser::link_chain($1,$3);
		//cout << "chaining var_decl : " << endl;
	}
	;

var_decl:	datatype NAME 	{
		$$=new FunctionParameter($1, $2);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
		free($2);
	}
	| datatype NAME '[' INUMBER ']'  {
		/* Neil - I need to fix this */
		DataType dt=DataType(INT8_ARR_TYPE+($1-INT8_TYPE));
		$$=new FunctionParameter(dt, $2, $4);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
		free($2);
	}
	|	datatype '&' NAME {
		DataType dt=DataType(INT8_REF_TYPE+($1-INT8_TYPE));
		$$=new FunctionParameter(dt, $3);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
		free($3);
	}
	|	/* empty */
		{
		$$=0;
		}
	;




stmt_list: stmt {
		$$=$1;
		if(qscript_parser::flag_next_stmt_start_of_block){
			qscript_parser::blk_heads.push_back($1);
			qscript_parser::flag_next_stmt_start_of_block=false;
			qscript_parser::blk_start_flag.pop_back();
		}

	}
	| stmt_list stmt{
		$1->next_=$2;
		$2->prev_=$1;
		$$=$2;
	}
	;


datatype: VOID_T
	| INT8_T
	|INT16_T
	|INT32_T
	|FLOAT_T
	|DOUBLE_T
	|STRING_T
	;

type_qual: CONST {
		   $$ = CONST_QUAL;
	}
	;

decl_stmt: datatype NAME ';' {
		$$ = qscript_parser::active_scope->insert($2, $1/*, line_no*/);
	}
	| type_qual datatype NAME '=' expression ';' {
	}
	| datatype NAME '=' expression ';'{
		$$ = qscript_parser::active_scope->insert($2, $1, $4);
	}
	| datatype NAME '[' expression ']' ';'{
		/* NxD: I have ordered the types in datatype so that this hack is possible I hope */
		DataType dt=DataType(INT8_ARR_TYPE+($1-INT8_TYPE));
		$$ = qscript_parser::active_scope->insert($2, dt, $4/*, line_no*/);
	}
	;




stmt:	question
	| expr_stmt
	| decl_stmt
	| stubs
	| named_attributes
	| cmpd_stmt  {
		$$ = $1;
	}
	| if_stmt
	| for_loop_stmt
	| stub_manip_stmts
	| goto_stmt
	| clear_stmt
	| column_stmt
	| newcard_stmt
	|	error ';' {
		fprintf (stderr, "continuing parse with errors around line_no: %d\n", qscript_parser::line_no);
		std::stringstream err_msg;
		err_msg << "continuing parsing"
			<< " file: " << qscript_parser::lex_location.fileName_
			<< " with errors around"
			<< " line: " << qscript_parser::lex_location.lineNo_
			<< " column: " << qscript_parser::lex_location.columnNo_ << std::endl;
		print_err(compiler_syntax_err
			, err_msg.str()
			, qscript_parser::lex_location.lineNo_, __LINE__, __FILE__);
		yyerrok;
		$$ = new ErrorStatement(qscript_parser::line_no);
	}
	;

for_loop_stmt:
	FOR '(' expression ';' expression ';' expression ')' {
		++qscript_parser::flagIsAForBody_;
		qscript_parser::for_loop_max_counter_stack.push_back($5);
	} cmpd_stmt {
		using qscript_parser::line_no;
		$$ = new ForStatement(FOR_STMT, line_no, $3, $5, $7, $10);

		--qscript_parser::flagIsAForBody_;
		qscript_parser::for_loop_max_counter_stack.pop_back();
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	;

cmpd_stmt: open_curly stmt_list '}' {
		$$ = qscript_parser::ProcessCompoundStatement($1, $2);
	}
	;

open_curly:	'{' {
		CompoundStatement * cmpdStmt = qscript_parser::ProcessOpenCurly();
		//qscript_parser::compound_body_stack.push_back(cmpdStmt);
		//cmpdStmt->nestedCompoundStatementStack_=qscript_parser::compound_body_stack;
		$$=cmpdStmt;
	}
	;



if_stmt:  IF '(' expression ')' stmt {
		using qscript_parser::if_line_no;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		using qscript_parser::XTCC_DEBUG_MEM_USAGE;
		CompoundStatement * cmpd_stmt = dynamic_cast<CompoundStatement*>($5);
		if (cmpd_stmt!=0) {
			cmpd_stmt->flagIsAIfBody_ = 1;
			$$=new IfStatement(IFE_STMT,if_line_no,$3,cmpd_stmt,0);
		} else 
			$$=new IfStatement(IFE_STMT,if_line_no,$3,$5,0);
		if(XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| IF '(' expression ')' stmt ELSE stmt {
		using qscript_parser::if_line_no;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		CompoundStatement * cmpd_stmt_if_body = dynamic_cast<CompoundStatement*>($5);
		if (cmpd_stmt_if_body) {
			cmpd_stmt_if_body->flagIsAIfBody_ = 1;
		}
		CompoundStatement * cmpd_stmt_else_body = dynamic_cast<CompoundStatement*>($7);
		if (cmpd_stmt_else_body) {
			cmpd_stmt_else_body->flagIsAIfBody_ = 1;
		}
		if (cmpd_stmt_if_body==0 && cmpd_stmt_else_body==0)
			$$=new IfStatement(IFE_STMT,qscript_parser::if_line_no,$3,$5,$7);
		else if (cmpd_stmt_if_body != 0 && cmpd_stmt_else_body !=0 ) 
			$$=new IfStatement(IFE_STMT,qscript_parser::if_line_no,$3,cmpd_stmt_if_body,cmpd_stmt_else_body);
		else if (cmpd_stmt_else_body !=0 && cmpd_stmt_if_body==0) 
			$$=new IfStatement(IFE_STMT,qscript_parser::if_line_no,$3,$5,cmpd_stmt_else_body);
		else 
			$$=new IfStatement(IFE_STMT,qscript_parser::if_line_no,$3,cmpd_stmt_if_body,$7);

		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
	}
	;


expr_stmt:	expression ';'
	{
		using qscript_parser::if_line_no;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		if($1->IsValid()){
			$$ = new ExpressionStatement(TEXPR_STMT, line_no, $1);
			if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
				mem_log($$, __LINE__, __FILE__, line_no);
			}
		} else {
			$$ = new ExpressionStatement(ERROR_TYPE, line_no, $1);
			if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
				mem_log($$, __LINE__, __FILE__, line_no);
			}
		}
	}
	;

goto_stmt: GOTO NAME ';' {
		$$ = new GotoStatement(GOTO_STMT, qscript_parser::line_no, $2);
		// free($2); ? is this required here
	}

clear_stmt: CLEAR '(' NAME ')' ';' {
		// free($3); ? is this required here
		$$ = new ClearStatement(CLEAR_STMT, qscript_parser::line_no, $3);
	}
	| CLEAR '(' NAME '[' expression ']' ')'';' {
		$$ = new ClearStatement(CLEAR_STMT, qscript_parser::line_no, $3, $5);
		// free($3); ? is this required here
	}
	;

column_stmt: COLUMN '(' expression ')' ';' {
		$$ = new ColumnStatement(COLUMN_STMT, qscript_parser::line_no, $3);
	}
	;

newcard_stmt: NEWCARD '(' expression ')' ';' {
		$$ = new NewCardStatement(COLUMN_STMT, qscript_parser::line_no, $3);
	}
	;


question: NAME text_expr_list qtype datatype range_allowed_values attribute_list';' {
		// Warning : xs is a global variable that is used here
		//$$ = qscript_parser::ProcessRangeQuestion($1, $2, $4);
		$$ = qscript_parser::ProcessRangeQuestion($1, "dummy question text", $4);
		//cout << "parsed range question : " << $1 << endl;
		question_attributes.Reset();
		using qscript_parser::xs;
		xs.reset();
		std::stringstream mesg;
		mesg << "fix memory leak problem introduced at this point";
		LOG_MAINTAINER_MESSAGE(mesg.str());
		// huge memory leak 
		text_expr_vec.clear();
	}
	| NAME text_expr_list qtype datatype range_allowed_values mutex_range attribute_list';' {
		$$ = qscript_parser::ProcessRangeQuestion($1, "dummy question text" , $4);
		//cout << "parsed range question : " << $1 << endl;
		question_attributes.Reset();
		qscript_parser::has_mutex_range = false;
		using qscript_parser::xs;
		xs.reset();
		std::stringstream mesg;
		mesg << "fix memory leak problem introduced at this point";
		LOG_MAINTAINER_MESSAGE(mesg.str());
		// huge memory leak 
		text_expr_vec.clear();
	}
	| NAME text_expr_list qtype datatype NAME attribute_list';' {
		$$ = qscript_parser::ProcessNamedQuestion($1, "dummy question text", $4, $5);
		//cout << "parsed named question : " << $1 << endl;
		question_attributes.Reset();
		std::stringstream mesg;
		mesg << "fix memory leak problem introduced at this point";
		LOG_MAINTAINER_MESSAGE(mesg.str());
		// huge memory leak 
		text_expr_vec.clear();
	}
	;

text_expr_list: text_expr
	|	text_expr_list ':' text_expr
	;

text_expr:	TEXT {
		text_expr_vec.push_back (new TextExpression(string($1)));
	}
	|	NAME '[' expression ']' {
		string name ($1);
		map<string,SymbolTableEntry*>::iterator sym_it = find_in_symtab(name);

		if ( sym_it  == qscript_parser::active_scope->SymbolTable.end() ){
			std::stringstream err_mesg;
			err_mesg << "symbol: " << name << " not found in symbol table. It should be a named_attribute list";
			print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
		} else {
			SymbolTableEntry * se = sym_it->second;
			if (se->type_ == NAMED_ATTRIBUTE_TYPE) {
				text_expr_vec.push_back (new TextExpression(new Unary2Expression (oper_arrderef, $1, $3)));
			} else {
				std::stringstream err_mesg;
				err_mesg << "symbol: " << name << " should be a named_attribute or a question";
				print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
			}
		}
	}
	| 	NAME '.' STUBS_LIST '[' expression ']' {

		string name ($1);
		map<string,SymbolTableEntry*>::iterator sym_it = find_in_symtab(name);
		if ( sym_it  == qscript_parser::active_scope->SymbolTable.end() ){
			std::stringstream err_mesg;
			err_mesg << "symbol: " << name << " not found in symbol table. It should be a named_attribute list";
			print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
		} else {
			SymbolTableEntry * se = sym_it->second;
			if (se->type_ == QUESTION_TYPE) {
				text_expr_vec.push_back (new TextExpression(se->question_, $5) );
				std::stringstream err_mesg;
				//err_mesg << "symbol: " << name << " question - unhandled case";
				//print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
			} else {
				std::stringstream err_mesg;
				err_mesg << "symbol: " << name << " should be a named_attribute or a question";
				print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
			}
		}

	}
	|	NAME {

		string name ($1);
		map<string,SymbolTableEntry*>::iterator sym_it = find_in_symtab(name);
		if ( sym_it  == qscript_parser::active_scope->SymbolTable.end() ){
			std::stringstream err_mesg;
			err_mesg << "symbol: " << name << " not found in symbol table. It should be a named_attribute list";
			print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
		} else {
			SymbolTableEntry * se = sym_it->second;
			if (se->type_ == QUESTION_TYPE) {
				text_expr_vec.push_back (new TextExpression (se->question_));
				std::stringstream err_mesg;
				//err_mesg << "symbol: " << name << " question - unhandled case";
				//print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
			} else {
				std::stringstream err_mesg;
				err_mesg << "symbol: " << name << " should be a named_attribute or a question";
				print_err(compiler_sem_err, err_mesg.str(), qscript_parser::line_no, __LINE__, __FILE__);
			}
		}
	}
	;

attribute_list:	/* empty */
	| ':' attributes
	;


attributes: attribute
	| attributes attribute
	;

attribute: HIDDEN {
		question_attributes.setHidden();
	}
	| ALLOW_BLANK {
		question_attributes.setAllowBlank();
	}
	;


expression: expression '+' expression {
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		using qscript_parser::mem_addr;
		$$=new BinaryExpression($1, $3, oper_plus);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '-' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_minus);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '*' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_mult);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '/' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_div);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '%' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_mod);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	'-' expression %prec UMINUS {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$ = new UnaryExpression($2, oper_umin);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '<' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_lt);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression '>' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_gt);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression LEQ expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_le);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression GEQ expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_ge);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression ISEQ expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_iseq);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	expression NOEQ expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_isneq);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| expression LOGOR expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_or);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| expression LOGAND expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$=new BinaryExpression($1, $3, oper_and);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| expression '=' expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$ = new BinaryExpression($1, $3, oper_assgn);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	NOT expression {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$ = new UnaryExpression($2, oper_not);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	INUMBER	{
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		$$ = new Unary2Expression($1);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	FNUMBER {
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		$$ = new Unary2Expression($1);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	|	NAME	{
		using qscript_parser::mem_addr;
		using qscript_parser::line_no;
		$$ = new Unary2Expression($1, oper_name );
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| 	NAME '[' expression ']' %prec FUNC_CALL {
		using qscript_parser::line_no;
		using qscript_parser::mem_addr;
		$$ = new Unary2Expression(oper_arrderef, $1,$3);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| NAME '(' expr_list ')' %prec FUNC_CALL{
		using qscript_parser::mem_addr;
		using qscript_parser::named_stubs_list;
		using qscript_parser::func_info_table;
		using qscript_parser::xs;
		using qscript_parser::q_type;
		using qscript_parser::no_mpn;
		using qscript_parser::trav_chain;
		using qscript_parser::skip_func_type_check;
		using qscript_parser::check_parameters;
		using qscript_parser::link_chain;
		using qscript_parser::stub_list;
		using qscript_parser::line_no;
		using qscript_parser::no_errors;
		//cout << "parsing Function call: name: " << $1 << endl;
		string search_for=$1;
		bool found=false;
		int32_t index=search_for_func(search_for);
		if(index!=-1) found=true;
		bool skip_type_check=skip_func_type_check(search_for.c_str());
		if( skip_type_check==false  && found==false ) {
			cerr << "ERROR: function call Error on line_no: "
				<< line_no << endl;
			cerr << "function : " << search_for
				<< " used without decl" << endl;
			++ no_errors;
			$$=new Unary2Expression(ERROR_TYPE);
			void *ptr=$$;
			mem_addr_tab m1(ptr, line_no, __FILE__, __LINE__);
			mem_addr.push_back(m1);
		} else {
			DataType my_type=func_info_table[index]->returnType_;
			AbstractExpression* e_ptr=trav_chain($3);
			FunctionParameter* fparam=
				func_info_table[index]->parameterList_;
			bool match=false;
			if(skip_type_check==false){
				match=check_parameters(e_ptr, fparam);
			}
			if(match || skip_type_check){
				//$$=new Unary2Expression(oper_func_call, my_type, $3, index, line_no);
				//$$=new Unary2Expression(oper_func_call, my_type, e_ptr, index, line_no);
				$$=new Unary2Expression(oper_func_call, my_type, e_ptr, index);
				void *ptr=$$;
				mem_addr_tab m1(ptr, line_no, __FILE__, __LINE__);
				mem_addr.push_back(m1);
			} else {
				$$=new Unary2Expression(ERROR_TYPE);
				void *ptr=$$;
				mem_addr_tab m1(ptr, line_no, __FILE__, __LINE__);
				mem_addr.push_back(m1);
			}
		}
	}
	|	TEXT {
		using qscript_parser::line_no;
		$$ = new Unary2Expression(strdup($1), oper_text_expr);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| 	'(' expression ')' %prec UMINUS{
		using qscript_parser::line_no;
		$$ = new UnaryExpression($2, oper_parexp );
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	| expression IN range_allowed_values {
		using qscript_parser::xs;
		using qscript_parser::line_no;
		$$ = new Binary2Expression($1, xs, oper_in);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
		xs.reset();
	}
	| TOSTRING '(' NAME ')' {
		$$ = new Unary2Expression($3, oper_to_string);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
	}
	| expression IN NAME {
		$$ = new Binary2Expression($1, $3, oper_in);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
	}
	| ISANSWERED '(' NAME ')' {
		$$ = new Unary2Expression ($3, oper_isanswered);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
	}
	| COUNT '(' NAME ')' {
		$$ = new Unary2Expression ($3, oper_count);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, qscript_parser::line_no);
		}
	}

	/*
	| NAME IN NAME {
		$$ = new Binary2Expression($1, $3, oper_in);
		if(qscript_parser::XTCC_DEBUG_MEM_USAGE){
			mem_log($$, __LINE__, __FILE__, line_no);
		}
	}
	*/
	;


expr_list: expression { $$=$1; }
	| expr_list ',' expression {
		$$=qscript_parser::link_chain($1,$3);
	}
	;

qtype: SINGLE_CODED { 
	       qscript_parser::q_type = spn; 
	       // we need this =1 when generating
	       // code for flat file creation
		qscript_parser::no_mpn = 1;
       }
	| MP '(' INUMBER ')' { qscript_parser::q_type = mpn;
		qscript_parser::no_mpn = $3;
	}
	;

mutex_range: MUTEX '(' mutex_range_list ')' { 
		     qscript_parser::has_mutex_range = true;
	     }
	;

mutex_range_list: mutex_range
	| mutex_range_list ',' mutex_range
	;


mutex_range: 	INUMBER '-' INUMBER {
		using qscript_parser::line_no;
		if($3<=$1){
			print_err(compiler_sem_err
					, "2nd number in range <= 1st number",
					line_no, __LINE__, __FILE__  );

		} else {
			qscript_parser:: mutex_range_set.add_range ( $1,$3);
		}
	}
	|	INUMBER {
		qscript_parser::mutex_range_set.add_indiv($1);
	}
	;


range_allowed_values:  '(' range_list ')' { }
	;


range_list: range
	| range_list ',' range
	;

range: 	INUMBER '-' INUMBER {
		using qscript_parser::line_no;
		if($3<=$1){
			print_err(compiler_sem_err
					, "2nd number in range <= 1st number",
					line_no, __LINE__, __FILE__  );

		} else {
			//qscript_parser:: xs.range.push_back( pair<int32_t,int32_t>($1,$3));
			qscript_parser:: xs.add_range ( $1,$3);
		}
	}
	|	INUMBER {
		//qscript_parser::xs.indiv.insert($1);
		qscript_parser::xs.add_indiv($1);
	}
	;

stubs:     STUBS_LIST NAME {
		using qscript_parser:: stub_list;
		using qscript_parser:: named_stubs_list;
		stub_list.resize(0);
	}'=' stub_list ';'{
		using qscript_parser::line_no;
		using qscript_parser:: stub_list;
		using qscript_parser:: named_stubs_list;
		//cout <<"got attribute_list size: " << attribute_list.size() << endl;
		string stub_name=$2;
		struct named_range* nr_ptr= new named_range(NAMED_RANGE
				, line_no, stub_name,stub_list);
		named_stubs_list.push_back(nr_ptr);
		//$$=0;
		$$ = nr_ptr;
	}
	;

named_attributes: NAMED_ATTRIBUTES NAME '=' named_attribute_list ';' {
		//$$ = new named_attribute_list (NAMED_ATTRIBUTE_TYPE, $2, vec_named_attribute_list);
		//qscript_parser::delete_manually_in_cleanup.push_back(
		$$ = qscript_parser::active_scope_list[0]->insert($2, NAMED_ATTRIBUTE_TYPE, qscript_parser::line_no, vec_named_attribute_list);
		//);
		vec_named_attribute_list.clear();
	}
	;

named_attribute_list: TEXT {
		vec_named_attribute_list.push_back ($1);
	}
	| named_attribute_list ',' TEXT {
		vec_named_attribute_list.push_back ($3);
	}
	;
	


stub_list: stub
	| stub_list stub
	;

stub:	TEXT INUMBER {
		using qscript_parser::stub_list;
		string s1=$1;
		int32_t code=$2;
		struct stub_pair pair1(s1,code);
		stub_list.push_back(pair1);
	}
	| TEXT INUMBER MUTEX {
		using qscript_parser::stub_list;
		string s1=$1;
		int32_t code=$2;
		struct stub_pair pair1(s1,code, true);
		stub_list.push_back(pair1);
		//cout << "chaining stublist" << endl;
	}
	;

stub_manip_stmts:
	  SETDEL '(' NAME ',' NAME ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_DEL
				, $3, $5);
	}
	| SETDEL '(' NAME ',' NAME '[' expression ']' ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_DEL
				, $3, $5, $7);
	}
	| SETADD '(' NAME ',' NAME ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_ADD
				, $3, $5);
	}
	| SETADD '(' NAME ',' NAME '[' expression ']' ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_ADD
				, $3, $5, $7);
	}
	| SETADD '(' NAME ',' range_allowed_values ')' ';' {
		using qscript_parser::xs;
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_ADD
				, $3, xs);
		xs.reset();
	}
	| SETDEL '(' NAME ',' range_allowed_values ')' ';' {
		using qscript_parser::xs;
		$$ = qscript_parser::setup_stub_manip_stmt( STUB_MANIP_DEL
				, $3, xs);
		using qscript_parser::xs;
		xs.reset();
	}
	| UNSET '(' NAME ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt_set_unset( STUB_MANIP_UNSET_ALL, $3);
	}
	| SETALL '(' NAME ')' ';' {
		$$ = qscript_parser::setup_stub_manip_stmt_set_unset( STUB_MANIP_SET_ALL, $3);
	}
	;




%%


#include "utils.h"
#include <unistd.h>
#include <string>

namespace qscript_parser {

template<class T> T* link_chain(T* &elem1, T* &elem2){
	if(elem1 && elem2){
		elem2->prev_=elem1;
		elem1->next_=elem2;
		return elem2;
	}
	else if(elem1){
		return elem1;
	} else {
		return elem2;
	}
}


template<class T> T* trav_chain(T* & elem1){
	if(elem1){
		while (elem1->prev_) elem1=elem1->prev_;
		return elem1;
	} else return 0;
}

//! The array size of a question inside a for loop
//! is determined by the nesting level of the question inside the
//! for loop and the maximum bound of the loop index - it is a multiplication
//! of all the maximum counters in the enclosing for loops
AbstractExpression * recurse_for_index(int32_t stack_index){
	//cerr << "entered: recurse_for_index: stack_index: " << stack_index << endl;
	if(stack_index==0){
		BinaryExpression * test_expr =
			dynamic_cast<BinaryExpression*>(
					for_loop_max_counter_stack[0]);
		if(test_expr==0){
			print_err(compiler_sem_err,
				" test expr should be a binary expression ",
				qscript_parser::line_no, __LINE__, __FILE__);
			return 0;
		} else if(test_expr->rightOperand_->IsIntegralExpression()
				&& test_expr->rightOperand_->IsConst()) {
			return test_expr->rightOperand_;
		} else {
			print_err(compiler_sem_err,
				" test expr not integer and const",
				qscript_parser::line_no, __LINE__, __FILE__);
			return test_expr->rightOperand_;
		}
	} else {
		BinaryExpression * test_expr =
			dynamic_cast<BinaryExpression*>(
				for_loop_max_counter_stack[stack_index]);
		if(test_expr==0){
			print_err(compiler_sem_err,
				" test expr should be a binary expression ",
				qscript_parser::line_no, __LINE__, __FILE__);
			return 0;
		} else if(test_expr->rightOperand_->IsIntegralExpression()
				&& test_expr->rightOperand_->IsConst()) {
			return new BinaryExpression(test_expr->rightOperand_,
				recurse_for_index(stack_index-1), oper_mult);
		} else {
			print_err(compiler_sem_err,
				" test expr not integer and const",
				qscript_parser::line_no, __LINE__, __FILE__);
			return test_expr->rightOperand_;
		}
	}
}

CompoundStatement* ProcessOpenCurly()
{
	++nest_lev;
	CompoundStatement * cmpdStmt= new CompoundStatement(CMPD_STMT,
			line_no, flagIsAFunctionBody_,
			flagIsAForBody_, for_loop_max_counter_stack);
	stack_cmpd_stmt.push_back(cmpdStmt);
	cmpdStmt->nestedCompoundStatementStack_=stack_cmpd_stmt;
	void *ptr=cmpdStmt;
	mem_addr_tab m1(ptr, line_no, __FILE__, __LINE__);
	mem_addr.push_back(m1);
	if(flagIsAFunctionBody_>=0){
		cmpdStmt->scope_=func_info_table[
			qscript_parser::flagIsAFunctionBody_]->functionScope_;
		// reset the flag
		qscript_parser::flagIsAFunctionBody_=-1;
	} else {
		cmpdStmt->scope_= new Scope();
	}
	flag_next_stmt_start_of_block=true;
	flag_next_question_start_of_block = true;
	blk_start_flag.push_back(flag_next_stmt_start_of_block);
	blk_question_start_flag.push_back(flag_next_question_start_of_block);
	active_scope_list.push_back(cmpdStmt->scope_);
	active_scope = cmpdStmt->scope_;
	return cmpdStmt;
}

CompoundStatement* ProcessCompoundStatement(CompoundStatement* cmpdStmt,
		AbstractStatement *stmt)
{

	active_scope_list.pop_back();
	int32_t tmp=active_scope_list.size()-1;
	if(tmp==-1) {
		active_scope = 0;
		print_err(compiler_internal_error
			, "Error: active_scope == 0 in ProcessCompoundStatement"
			": should never happen :... exiting",
				line_no, __LINE__, __FILE__  );
		exit(1);
	} else {
		active_scope = active_scope_list[tmp];
	}
	struct AbstractStatement* head_of_this_chain=blk_heads.back();
	if(blk_start_flag.size() > 0) {
		flag_next_stmt_start_of_block = blk_start_flag[blk_start_flag.size()-1];
	}
	if (blk_question_start_flag.size()>0) {
		//flag_next_question_start_of_block = blk_question_start_flag[blk_question_start_flag.size()-1];
		blk_question_start_flag.pop_back();
		flag_next_question_start_of_block = blk_question_start_flag.back();
	}
	if(  head_of_this_chain==0){
		//cerr << "Error in compiler : compoundBody_:  " << __FILE__ << __LINE__ << endl;
		//++no_errors;
		print_err(compiler_internal_error
			, "Error: head_of_this_chain == 0 in "
			"ProcessCompoundStatement : should never happen :"
			"... exiting"
			, line_no, __LINE__, __FILE__  );
		exit(1);
	} else {
		cmpdStmt->compoundBody_ = head_of_this_chain;
		blk_heads.pop_back();
	}

	//! update the counter of enlosing CompoundStatement with
	//! the number of questions in this CompoundStatement being popped of
	//! right now
	if(stack_cmpd_stmt.size()>1){
		CompoundStatement * popped_off_cmpd_stmt_ptr=stack_cmpd_stmt.back();
		stack_cmpd_stmt.pop_back();
		CompoundStatement * current  = stack_cmpd_stmt.back();
		current->counterContainsQuestions_+=
			(popped_off_cmpd_stmt_ptr->counterContainsQuestions_);
	}
	//$$=$1;
	return cmpdStmt;
}

// NxD: 10-Jun-2010
// Need to make changes here - create a new struct to store variable name and type
// and dump the entire scope into the map
// later the question::GenerateCode will
// decide by looking if it is an array question or a simple
// question and generate the appropriate save restore scope code
AbstractStatement * ProcessRangeQuestion(const string &name
		, const string & q_text, const DataType& dt )
{

	//vector<string> active_push_vars;
	//vector<string> active_pop_vars;
	//for(unsigned int32_t i=0; i< active_scope_list.size(); ++i){
	//	Scope* sc_ptr= active_scope_list[i];
	//	sc_ptr->print_scope(name, active_push_vars, active_pop_vars);
	//}
	//string q_push_name = name + "_push";
	//string q_pop_name = name + "_pop";
	//map_of_active_vars_for_questions[q_push_name] = active_push_vars;
	//map_of_active_vars_for_questions[q_pop_name] = active_pop_vars;
	vector <ActiveVariableInfo* > av_info;
	PrintActiveVariablesAtScope(active_scope_list, av_info);


	AbstractExpression * arr_sz=0;
	RangeQuestion * q=0;
	if(stack_cmpd_stmt.size()==0){
		print_err(compiler_internal_error
			, "compound statement stack is 0 when parsing"
			"a question... exiting",
				line_no, __LINE__, __FILE__  );
		exit(1);
	}
	CompoundStatement * cmpd_stmt_ptr=stack_cmpd_stmt.back();
	if(qscript_parser::flagIsAForBody_){
		//cout << "flagIsAForBody_: "
		//	<< qscript_parser::flagIsAForBody_ << endl;
		arr_sz = qscript_parser::recurse_for_index(
			qscript_parser::for_loop_max_counter_stack.size()-1);
		q= new RangeQuestion(QUESTION_ARR_TYPE, line_no,
			name, ::text_expr_vec, q_type, no_mpn, dt, xs
			//, arr_sz
			, qscript_parser::for_loop_max_counter_stack
			, cmpd_stmt_ptr, av_info, question_attributes, mutex_range_set
			);
		qscript_parser::delete_manually_in_cleanup.push_back(
			active_scope_list[0]->insert(name.c_str(), QUESTION_ARR_TYPE, q));
		//ostringstream s1, s2;
		//arr_sz->print_expr(s1, s2);
		//cerr << "s1: " << s1.str() << ", s2: " << s2.str() << endl;
	} else {
		q= new RangeQuestion(QUESTION_TYPE, line_no,
			name, ::text_expr_vec, q_type, no_mpn, dt, xs, cmpd_stmt_ptr, av_info
			, question_attributes, mutex_range_set
			);
		qscript_parser::delete_manually_in_cleanup.push_back(
			active_scope_list[0]->insert(name.c_str(), QUESTION_TYPE, q));
	}
	++(cmpd_stmt_ptr->counterContainsQuestions_);
	//$$=q;

	question_list.push_back(q);
	/*
	cout << "question_list: questions are " << endl;
	for(int32_t i=0; i<question_list.size(); ++i){
		cout << question_list[i]->questionName_ << endl;
	}
	*/
	xs.reset();
	mutex_range_set.reset();
	// questions always get pushed in Scope level 0 as they
	// are global variables - no matter what the level of nesting
	// I need to modify the insert in Scope to
	// take a 3rd parameter which is a AbstractQuestion *
	// and store that into the symbol table
	// I should be able to retrieve that
	// AbstractQuestion* pointer later
	if (flag_next_question_start_of_block) {
		q->isStartOfBlock_ = true;
		flag_next_question_start_of_block = false;
		blk_question_start_flag[blk_question_start_flag.size()-1] = false;
		//cout << "blk_question_start_flag.size(): " << blk_question_start_flag.size() << endl;
		//cout << "At question: " << name << ", resetting flag_next_question_start_of_block = false " << endl;
		//cout << " blk_question_start_flag looks like this: " << endl;
		//for (int i=0; i<blk_question_start_flag.size(); ++i) {
		//	cout << " " <<blk_question_start_flag[i] ;
		//}
		//cout << endl;
	}
	
	return q;
}

AbstractStatement * ProcessNamedQuestion(const string &name
			, const string & q_txt , const DataType& dt
			, const string & attribute_list_name )
{

	// This is preparatory work
	// for jumping between questions
	// store
	//vector<string> active_push_vars;
	//vector<string> active_pop_vars;
	//for(unsigned int32_t i=0; i< active_scope_list.size(); ++i){
	//	Scope* sc_ptr= active_scope_list[i];
	//	sc_ptr->print_scope(name, active_push_vars, active_pop_vars);
	//}
	//string q_push_name = name + "_push";
	//string q_pop_name = name + "_pop";
	//map_of_active_vars_for_questions[q_push_name] = active_push_vars;
	//map_of_active_vars_for_questions[q_pop_name] = active_pop_vars;
	vector <ActiveVariableInfo* > av_info;
	PrintActiveVariablesAtScope(active_scope_list, av_info);

	bool found=false;
	struct named_range* nr_ptr = 0;
	for(uint32_t i=0; i<named_stubs_list.size(); ++i){
		nr_ptr = named_stubs_list[i];
		if(nr_ptr->name==attribute_list_name){
			found=true; break;
		}
	}
	if(!found){
		print_err(compiler_sem_err, string("named_stubs_list ")
			+ attribute_list_name + string(" not found \n"), line_no,
			__LINE__, __FILE__);
	}

	if(stack_cmpd_stmt.size()==0){
		print_err(compiler_internal_error, "compound statement stack "
			"is 0 when parsing a AbstractQuestion... exiting"
			, line_no, __LINE__, __FILE__  );
		exit(1);
	}
	CompoundStatement * cmpd_stmt_ptr=stack_cmpd_stmt.back();
	AbstractExpression * arr_sz=0;
	NamedStubQuestion* q=0;
	if(qscript_parser::flagIsAForBody_){
		//cout << "flagIsAForBody_: "
		//	<< qscript_parser::flagIsAForBody_ << endl;
		arr_sz = qscript_parser::recurse_for_index(
			qscript_parser::for_loop_max_counter_stack.size()-1);
		q=new NamedStubQuestion(QUESTION_ARR_TYPE, line_no
				, name, ::text_expr_vec, q_type, no_mpn, dt , nr_ptr
				,qscript_parser::for_loop_max_counter_stack
				, cmpd_stmt_ptr, av_info, question_attributes);
		qscript_parser::delete_manually_in_cleanup.push_back(
			active_scope_list[0]->insert(name.c_str(), QUESTION_ARR_TYPE, q));
	} else {
		q=new NamedStubQuestion(QUESTION_TYPE,
			line_no, name, ::text_expr_vec, q_type, no_mpn, dt, nr_ptr
			, cmpd_stmt_ptr, av_info, question_attributes);
		qscript_parser::delete_manually_in_cleanup.push_back(
				active_scope_list[0]->insert(name.c_str(), QUESTION_TYPE, q));
	}
	question_list.push_back(q);
	//$$=q;
	++(cmpd_stmt_ptr->counterContainsQuestions_);

	if (flag_next_question_start_of_block) {
		q->isStartOfBlock_ = true;
		flag_next_question_start_of_block = false;
		//blk_question_start_flag[blk_question_start_flag.size()-1] = false;
		//cout << "blk_question_start_flag.size(): " << blk_question_start_flag.size() << endl;
		//cout << "At question: " << name << ", resetting flag_next_question_start_of_block = false " << endl;
		//cout << " blk_question_start_flag looks like this: " << endl;
		//for (int i=0; i<blk_question_start_flag.size(); ++i) {
		//	cout << " " <<blk_question_start_flag[i] ;
		//}
		//cout << endl;
	}

	return q;
}

// Close namespace
}
